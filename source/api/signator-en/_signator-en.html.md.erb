# **Signator API**

![Logo](https://demo.signator.eu/assets/img/default/logo.svg)

**GENERAL**

This document outlines available methods for integrating the Signator system and SystemX (a generic system). Signator offers centralized document signing using digital certificates, seals, or timestamps.

## Signator introduction

> The following examples will utilize **authorization token as a query parameter**.

To utilize the requests provided in this documentation, it is essential to set up an environment defined with parameters such as gateway host and authorization key.

Here's an example of API structure for an endpoint:

#### HTTP Request

`GET {{GATEWAYHOST}}/v/1/integrator/pdf/signature/certificates/`

To test requests in a test environment, the demonstrational gateway host can be found in the table below.
The necessary authorization key must be obtained from Vizibit.
Once acquired, the authorization key should be included either as a bearer token (in 'Authorization' header) or as a query parameter ('authorization_key') within the testing request.

#### Query Parameters

Parameter | Value
--------- | -----------
**GATEWAYHOST** | https://demo.signator.eu
**authorization_key** | Your authorization key. Add in a header of request or as **query** parameter.

Parameter sent in request need to be inserted instead of parameter's name in curly brackets (e.g. "/v/1/document/**{{document_id}}**/attributes/").

## Authorization

### Authorization to the Signator interface

Authorization to the Signator interface is performed using a JWT token.

The contractor must request a JWT token from Vizibit (different tokens will be used for testing and production environments, as well as for communication to different systems).

**The token contains:**

- duration of the access
- identifier of the service accessing the interface

**The JWT token is included in the request sent to the interface in one of the following ways:**

- in the query parameter **authorization\_key**
- in the request **Authorization** header as a **Bearer Token**

### Authorization to the System X interface

The contractor should support one of the following authorization models for authorizing Signator request:

- Basic authentication
- JWT tokens

## Digital signing of a document (e-Signature)

Usual steps for digital signing of a document includes several phases:

- **Phase 1:** Creating a document for approval/signing and signing workflow
  - importing an pdf document to be digitally signed
  - document certificate verification (optional)
  - digital signing with electronic seal (optional)
  - defining signers and types of digital signatures
  - defining the position of the visual part of the digital signature
  - adding attachments
  - adding attributes to the pdf document to be verified
  - starting the approval and signing proces
- **Phase 2** : Document signing
  - all defined participants have digitally signed the document

Aforementioned steps of **Phase 1** can be performed through three options:

- **Option 1: manual** - through the Signator application by the person creating and initiating the signing process (initiator)
- **Option 2: semi-automatic** - through partial API integration - document is sent to Signator and Initiator manually needs to define the position of visual representation of digital signature on the document and start the workflow
- **Option 3: automatic** - through API integration with other systems

#### Option 1: Manual start of the digital signing workflow

Steps are identical to those described in Phase 1 and are performed by the initiator in the Signator application.

#### Option 2: Semi-automatic start of the digital signing workflow

This option allows a simple level of integration by sending a document that needs to be signed from the SystemX to the Signator through a defined API. SystemX then opens the Signator application in a new browser tab (automatic SSO login) so that the person initiating the signing workflow could define the signers, signing sequence, signature types, and the locations of the visual parts of the signature.

![Semi-automatic start of the digital signing workflow](https://assets.signator.eu/share/img/slika_1_api_doc.png)

The specificity of this option is that SystemX opens a new tab to access the Signator application and the specific document. The document is opened in the second step of the document signing wizard. The initiator (usually the clerk or secretary) is expected to manually add the document signers and manually position the signature images on the document itself. The initiator finally starts the signing workflow.

The advantages of this integration model are:

- in the SystemX application it is not necessary to create and send the list of signers to the Signator system, signature level, standard and other parameters. This part is manually defined by the initiator in the Signator system where it is already implemented
- faster implementation

#### Option 3: Automatic start of the digital signing workflow

This option allows full automation and integration by sending all required parameters from SystemX to start the digital signin workflow in Signator. This means that all signers, digital signing sequence, signature levels (QES, AES or SES) and the location of signatures on the document are defined.

![Automatic start of the digital signing workflow](https://assets.signator.eu/share/img/slika_2_api_doc.png)

Steps to verify the certificate on the document and to seal the document are optional.

The advantages of this integration model are:

- the process is fully automated. After the document is forwarded to the Signator with all parameters, the digital signing process is started automatically. Signers sequentially receive email notifications about the document waiting for signing,
- it is possible to send more documents for signing, and the user can then sign them with a digital signature in Signator application

### **Representation of the integration model for e-Signature**

![Representation of the integration model for e-Signature](https://assets.signator.eu/share/img/slika_3_api_doc.png)

#### Function: StartApprovalProcess

> JSON Body input:

```json
{
  "file": "JVBERi0xLjUKJ … shortened for readability … 3MAolJUVPRgo=",
  "fileType": "pdf",
  "fileName": "Document name",
  "initiator": "example.address@domain.com",
  "participants": [
    {
      "email": "example.address@domain.com",
      "role": "SIGNER",
      "signatureLevel": "QES",
      "signatureImage": {
        "page": 1,
        "widgetOffsetX": 100,
        "widgetOffsetY": 200,
        "widgetWidth": 300,
        "widgetHeight": 150
      }
    }
  ],
  "attachments": [
    {
      "file": "JVBERi0xLjUKJ … shortened for readability … 3MAolJUVPRgo=",
      "fileType": "xml",
      "fileName": "Attachment-12"
    }
  ],
  "attributes": [
    {
      "attributeKey": "string",
      "attributeValue": "string"
    }
  ],
  "deliveryAddresses": [
    "example.address@demo.eu",
    "example.demo@address.eu"
  ]
}
```

> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
{
  "documentId": 123,
  "documentUrl": "https://esign.example.com/#/upload/v/1/documents/123"
  "documentSignUrl": "https://esign.example.com/#/v/1/documents/123"
}
```

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

- SystemX sends a document to be digitally signed by one or more persons to Signator system

`POST {{GATEWAYHOST}}/v/1/document/{{calling_system}}`

**Route Values**

Parameter | Default | Description
--------- | ------- | -----------
calling_system |  | identifier for the calling system

  - function name: **StartApprovalProcess**
  - implemented in: Signator
  - caller: SystemX
  - input parameters:
    - &quot;file&quot;\* - pdf document in base64 format
    - &quot;fileType&quot;\* - file type
    - &quot;fileName&quot;\* - name of the pdf document to digitally sign
    - &quot;initiator&quot;\* - email of the person who sent the document from SystemX for digital signing
    - &quot;participants&quot; - [email, role, signatureLevel, signatureImage] - list of signers defined in sequential order (_optional parameter - if this parameter is used, be sure to fill in the following attributes_)
      - &quot;email&quot;\* - email address of the signer
      - &quot;role&quot; \* - role of the signer - APPROVER, SIGNER
          - Note: if APPROVER is sent, then the option &quot;SES&quot; must be selected in signature level
      - &quot;signatureLevel&quot;\*
          - signatureLevel possible values: &quot;QES&quot; (qualified signature), &quot;AES&quot; (advanced signature), &quot;SES&quot; (stamp). Applies to the SIGNER role only.
      - [&quot;signatureImage&quot; - signature image with values:](#positioning-of-the-signature-image-seal)
          - &quot;page&quot;\* - page of the document on which the signature image will be positioned.
          - &quot;widgetOffsetX&quot;\* - offset from the lower left corner along the x axis.
          - &quot;widgetOffsetY&quot;\* - offset from the lower left corner along the y axis.
          - &quot;widgetWidth&quot;\* - the width of the image widget (if the document has a defined signature field this value is ignored).
          - &quot;widgetHeight&quot;\* - height of the image widget (if the document has a defined signature field this value is ignored).
    - attachments [file\*, fileType, fileName\*] - list of attachments to the document to be digitally signed. (_optional parameter - if this parameter is used, be sure to fill in the attributes marked with &quot;\*&quot;_)
      - &quot;file&quot; - attachment in base64 format
      - &quot;fileType&quot; - document type
      - &quot;fileName&quot; - attachment name
    - attributes [attributeKey\*, attributeValue\*] - attribute list (those have to be agreed upon before implementation) which will be sent with the document to be digitally signed. (_optional parameter - if this parameter is used, be sure to fill in the following attributes_)
      - &quot;attributeKey&quot;
      - &quot;attributeValue&quot;
    - deliveryAddresses[list<string>] - list of email addresses of users who do not participate in document verification, and to whom the signed document needs to be delivered upon completion of the signing
  - output:
    - &quot;documentId&quot; - ID of the document in the Signator system for later possible retrieval of the status and attributes of the document
    - &quot;documentUrl&quot; - link to open the document in edit mode in Signator so that the initiator can define all parameters of the signing workflow (signers, signature types, signature position)
    - &quot;documentSignUrl&quot; - link to open the document in signing mode in Signator so that the user can immediately start document signing

### **Optional functions**

#### Function: **ShareFileToRecepient**

> JSON Body input:

```json
{
  "file": "JVBERi0xLjUKJ … shortened for readability … 3MAolJUVPRgo=",
  "fileType": "pdf",
  "fileName": "Document name",
  "initiator": "example.address@domain.com",
  "recipients": [
    {
      "email": "example.address@domain.com",
      "oib": 1
    }
  ],
  "attachments": [
    {
      "file": "JVBERi0xLjUKJ … shortened for readability … 3MAolJUVPRgo=",
      "fileType": "xml",
      "fileName": "Attachment-12"
    }
  ],
  "asAttachment": true
}
```
> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
{
  "documentId": 123
}
```
> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

Document can be delivered to the user of Signator application for inspection in several ways:

- to his user inbox on Signator portal
- send e-mail with a link to the document on the Signator portal
- send e-mail with the document as an attachment

`POST {{GATEWAYHOST}}/v/1/document/delivery/`

  - function name: ShareFileToRecepient
  - implemented in: Signator
  - caller: SystemX
  - input parameters:
    - &quot;file&quot;\* - pdf document in base64 format
    - &quot;fileType&quot; - file type
    - &quot;fileName&quot;\* - name of the document for delivery
    - &quot;initiator&quot;\* - email of the owner of the document
    - &quot;recipients&quot;\* [e mail, OIB] - list of recipients with values
    - Attachments\* [file\*, fileType, fileName\*] - list of attachments to the document to be digitally signed
    - &quot;asAttachment&quot; (_optional parameter)_ - send the document to e-mail as attachment
  - output:
    - &quot;documentId&quot; \* - ID of the document delivered to the recipient


#### Function: **GetDocumentAttributes**

> Input **document_id** in Route

> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
[
  {
    "attributeKey": "string",
    "attributeValue": "string"
  }
]
```

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

- Get all document attributes by documentID

`GET {{GATEWAYHOST}}/v/1/document/{{document_id}}/attributes/`

**Route Values**

Parameter | Default | Description
--------- | ------- | -----------
document_id |  | Id of the document.

  - function name: **GetDocumentAttributes**
  - implemented in: Signator
  - caller: SystemX
  - input parameters:
    - &quot;documentId&quot;\* - ID of the document for which all attributes need to be retrieved
  - output:
    - DocumentAttributes[attributeKey , attributeValue] - list of attribute names and their values ​​defined in the Signator system.

#### Function: **GetDocumentStatus**

> JSON Body input:

```json
[
  {
    "documentId": 123
  }
]
```
> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
[
  {
    "documentId": 123,
    "worfklowStatus": "PENDING"
  }
]
```

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```


- Retrieve document statuses by documentID

`POST {{GATEWAYHOST}}/v/1/document/status/`

  - function name: **GetDocumentStatus**
  - implemented in: Signator
  - caller: SystemX
  - input parameters:
    - DocumentIdentifier\* [documentId] - list of documentIds for which it is necessary to retrieve status
  - output:
    - Status[documentId\*, DocumentStatus] - list of documentIds with their statuses
      - DocumentStatus possible values:
          - &quot;FINISHED&quot; - all participants signed/approved the document,
          - &quot;CANCELED&quot; - the initiator of the workflow canceled the workflow,
          - &quot;REJECTED&quot; - one of the participants of the workflow refused to sign/approve the document ,
          - &quot;PENDING&quot; - waiting for the action of one of the participants in the workflow,
          - &quot;DELETED&quot; - the workflow is deleted,
          - &quot;DRAFT&quot; - the workflow is defined, but there are no participants

#### Function: **GetApprovedDocument**

> Input **document_id** in Route

> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
{
  "documentId": 123,
  "signedFile": "JVBERi0xLjUKJ … shortened for readability … 3MAolJUVPRgo="
}
```

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

- Get the signed document

`GET {{GATEWAYHOST}}/v/1/document/{{document_id}}/`

**Route Values**

Parameter | Default | Description
--------- | ------- | -----------
document_id |  | Id of the document.

  - function name: **GetApprovedDocument**
  - implemented in: Signator
  - caller: SustavX
  - input parameters:
    - &quot;documentId&quot;\* - ID of the signed document that needs to be retrieved
  - output:
    - &quot;documentId&quot;\* - ID of signed document
    - &quot;signedFile&quot;\* - digitally signed PDF document in base64 format


#### Function: **UpdateDocumentAttributes**


`PUT {{GATEWAYHOST}}/v/1/document/{{document_id}}/attributes/`

> JSON Body input:

```json
[
  {
    "attributeKey": "string",
    "attributeValue": "string"
  }
]
```

> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
{
  "documentId": 123
}
```

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

- Update document attributes

**Route Values**

Parameter | Default | Description
--------- | ------- | -----------
document_id |  | Id of the document.

  - function name: **UpdateDocumentAttributes**
  - implemented in: Signator
  - caller: SystemX
  - input parameters:
    - &quot;documentId&quot;\* - ID of the document to which you want to update the attributes
    - DocumentAttributes[attributeKey\*, attributeValue\*] - a list of attribute names and their values ​​defined in the Signator system.
  - output:
    - &quot;documentId&quot; \* - ID of updated document


#### Function: **VerifyDocumentCertificates**

`POST {{GATEWAYHOST}}/v/1/integrator/pdf/signature/certificates/`

> JSON Body input:

```json
{
  "File": "JVBERi0xLjUKJ … shortened … 3MAolJUVPRgo="
}
```

> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
{
  "SignatureValid": true,
  "Signatures": [
    {
      "Valid": true,
      "Timestamped": true,
      "Time": "2021-01-01T23:59:59",
      "Qualified": "Granted",
      "ChainValidationStatus": "Valid",
      "Subject": "/C=HR/O=TEST/OU=Signature/S=FIRSTNAME/G=LASTNAME/SN=PNOHR-00000000001/CN=FIRSTNAME LASTNAME",
      "Status": "Valid",
      "Type": "Standard"
    }
  ]
}
```

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

- Function checks if all digital signatures are valid and qualified.


  - function name: **VerifyDocumentCertificates**
  - implemented in: Signator
  - caller: SystemX
  - input parameters:
    - &quot;File&quot;\* - document
  - output:
    - &quot;SignatureValid&quot;\* - response whether all signatures are valid
    - &quot;Signatures[]&quot; \* - list of signatures with details for each signature
      - SignatureDetails values:
          - &quot;Valid&quot; - signature validity
          - &quot;Timestamped&quot; - whether the signature has a time stamp
          - &quot;Time&quot; - signature time (if the signature does not have a time stamp, it returns the server time)
          - &quot;Qualified&quot; - qualification status
          - &quot;ChainValidationStatus&quot; - chain validation status
          - &quot;Subject&quot; - signer information
          - &quot;Status&quot; - signature status
          - &quot;Type&quot; - signature type

#### **Notes**

1. Interfaces use REST for calls to the Signator API
2. All data exchange is performed using **HTTP** in **JSON** format.

#### Function: **FinishApprovalProcess**

`POST {{GATEWAYHOST}}/v/1/document/`

> JSON Body input:

```json
{
  "documentId": 123,
  "documentUrl": "esign.example.com/#/v/1/document/3",
  "signedFile": "JVBERi0xLjUKJ … shortened for readability … 3MAolJUVPRgo=",
  "fileName": "Document name",
  "status": "FINISHED",
  "attributes": [
    {
      "attributeKey": "string",
      "attributeValue": "string"
    }
  ]
}
```

> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
{
  "documentId": 123
}
```
> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

After the document is digitally signed, Signator calls the function on the SystemX side to pass it the digitally signed document.

- function name: **FinishApprovalProcess**
- implemented in: SystemX
- caller: Signator
- input parameters:
  - &quot;documentId&quot;\* - ID of the digitally signed document as a reference to SystemX which is the subject document
  - &quot;documentUrl&quot;\* - the path of the digitally signed document. digitally signed document can be opened from SystemX by opening the path of a specific document. The document can be seen by a person if he/she is a participant in the digital signing workflow or the document has been shared with him/her.
  - &quot;SignedFile&quot;\* - digitally signed document in the form of base64
  - &quot;status&quot;\* - document status for documentId
      - DocumentStatus possible values:
          - &quot;FINISHED&quot; - all participants signed/approved the document,
          - &quot;CANCELED&quot; - the initiator of the workflow canceled the workflow,
          - &quot;REJECTED &quot;- one of the participants in the workflow refused to sign/approve the document
  - DocumentAttributes\* [attributeKey, attributeValue] - list of attribute names of the digitally signed document and their values.
- output:
  - &quot; documentId&quot;\* - Document ID in Signator system

#### Function: **GetDocumentAttributes**

`POST {{GATEWAYHOST}}/v/1/document/attributes/`

> JSON Body input:

```json
{
  "documentId": 123
}
```

> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
[
  {
    "attributeKey": "string",
    "attributeValue": "string"
  }
]
```

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

- Get all document attributes by documentID

  - function name: **GetDocumentAttributes**
  - implemented in:systemX:
  - caller: Signator
  - input parameters:
    - &quot;documentId&quot;\* - ID of the document for which all attributes need to be retrieved
  - output:
    - DocumentAttributes [attributeKey\*, attributeValue\*] - list of attribute names and their values which are defined in SystemX.

**Note:** The Contractor can define the endpoint name himself **,** while the format of the request and response itself should be in the format specified in the definition.

### Error feedback
All errors return the HTTP status code **400** , unless an unforeseen situation has occurred. In that case HTTP status code is **500.**

All errors are returned as **JSON**.

#### List of possible errors on Signator interface

- 361 - User not found
- 320 - Undefined role
- 431 - Unable to create workflow with provided data
- 1 - Workflow not found
- 3 - No workflow identifier
- 1001 - Expired JWT authorization token
- 4000 - authorization token invalid

In case of any error, processing is interrupted at that moment and the error response is returned to the caller.

A more detailed description of the error will be found in the info element.

## Electronic document seal (e-Seal)

### Representation of the integration model for e-Seal

![Representation of the integration model for e-Seal](https://assets.signator.eu/share/img/slika_5_api_doc.png)

### Digital signing of document with e-Seal

The document can be digitally signed with a certificate issued to the company using an HSM device. There are several digital signing models with respect to seal visualization that are listed in the following chapters.

There are three options to seal a document:

- **Option 1** : seal a document with a fixed layout and the position of the seal itself
- **Option 2** : seal a document with arbitrary text in the visual part of the seal and an arbitrary seal location
- **Option 3** : seal a document with arbitrary text but a fixed position
- **Option 4:** seal a document with arbitrary image and seal location

#### Option 1: e-Seal for electronic deed

> JSON Body input:

```json
{
  "File": "JVBERi0xLjUKJ … shortened … 3MAolJUVPRgo=",
  "RecordNumber": "123/ab/731",
  "SystemId": "ePotpis",
  "SignatureOptions": {
    "Reason": "New contract",
    "Location": "Zurich",
    "SignerContactInfo": "john.doe@example.com, Example ltd.",
    "SignerName": "John Doe"
  }
}
```

> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
{
  "SignedFile": "JVBERi0xLjUKJ … shortened … 3MAolJUVPRgo=",
  "StorageProviderDocumentId": "C211D9D33ECBAC28F54CC",
  "RecordNumber": "123/ab/731"
}
```

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

`POST {{GATEWAYHOST}}/v/1/integrator/pdf/seal/electronic_deed/fixed/`

Sealing a document with a fixed layout and the position of the seal itself.

This option is intended for sealing a document with predefined dimensions and the appearance of the seal in accordance with the electronic deed. The document must have a defined blank space at the bottom of the page because the visual part of the electronic seal will be copied over that part.

- function name: **SealDocumentWithFixedElectronicDeed**
- implemented in: Signator
- caller: SystemX
- input parameters:
  - &quot;File&quot;\* - ID of the document in SystemX
  - &quot;RecordNumber\* - ID of the document in central document management system
  - &quot;SystemID&quot;\* - pre-agreed system code that integrates with Signator system
  - &quot;SignatureOptions&quot;
      - &quot;Reason&quot; - signature reason
      - &quot;Location&quot; - location where the signature was created
      - &quot;SignerContactInfo&quot;- information about the signer
      - &quot;SignerName&quot; - name of the signer
- output:
  - &quot;SignedPDF&quot; - signed pdf document in base 64 format
  - &quot;StorageProviderDocumentId&quot;
  - &quot;RecordNumber&quot;

Seal layout:

![Seal layout](https://assets.signator.eu/share/img/slika_6_api_doc.png)

Location where the electronic seal is positioned (valid only for A4 paper dimensions):

![Seal location](https://assets.signator.eu/share/img/slika_7_api_doc.png)

- Electronic seal dimensions (valid only for A4 paper dimensions):
  - height : 45 mm
  - width: 122 mm

#### Option 2: e-Seal with arbitrary text and position

Seal a document with arbitrary text in the visual part of the seal and arbitrary location of the seal.

#### Function: **SealDocumentWithPositionedText**

> JSON Body input:

```json
{
  "File": "JVBERi0xLjUKJ … shortened … 3MAolJUVPRgo=",
  "SignatureText": {
    "Text": "Example text",
    "Page": 1,
    "WidgetOffsetX": 100,
    "WidgetOffsetY": 200,
    "WidgetWidth": 300,
    "WidgetHeight": 150
  },
  "SignatureOptions": {
    "Reason": "New contract",
    "Location": "Zurich",
    "SignerContactInfo": "john.doe@example.com, Example ltd.",
    "SignerName": "John Doe"
  }
}
```

> If successful the above command returns code **200 OK** and Signed PDF document

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

`POST {{GATEWAYHOST}}/v/1/integrator/pdf/seal/text/positioned/`

- function name: **SealDocumentWithPositionedText**
- implemented in: Signator
- caller: SystemX
- input parameters:
  - &quot;File&quot;\* - document to be sealed
  - [&quot;SignatureText&quot; \* - text to be added to the visual part of the seal](#positioning-of-the-signature-image-seal)
      - &quot;Text&quot;\* - text in the visual part of the digital seal
      - &quot;Page&quot; - page on which the seal is placed
      - &quot;WidgetOffsetX&quot; - seal position - lower left corner, x axis
      - &quot;WidgetOffsetY&quot; - seal position - lower left corner, y axis
      - WidgetWidth &quot;- seal image height
      - &quot; WidgetHeight &quot;- seal image width
  - &quot; SignatureOptions&quot;\*
      - &quot; Reason &quot;- signature reason
      - &quot; Location &quot;- location where signature was created
      - &quot; SignerContactInfo &quot;- signer information
      - &quot; SignerName &quot;- signer name
- output:
  - binary response with &quot;application/pdf&quot; content type

#### Option 3: e-Seal with arbitrary text and fixed position

Sealing document with some text with fixed position.

#### Function: **SealDocumentWithFixedText**

> JSON Body input:

```json
{
  "File": "JVBERi0xLjUKJ … shortened … 3MAolJUVPRgo=",
  "Text": "Sample text"
}
```

> If successful the above command returns code **200 OK** and Signed PDF document

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

`POST {{GATEWAYHOST}}/v/1/integrator/pdf/seal/text/fixed/`

- function name: **SealDocumentWithFixedText**
- implemented in: Signator
- caller: SystemX
- input parameters:
  - &quot;File&quot;\* - document to be sealed
  - &quot;Text&quot;\* - text to be added to the visual part of the seal
  - &quot;ExternalSignerRegistryId&quot; - Optional parameter, this parameter enables switching between multiple different signing certificates when performing the eseal call
- output:
  - binary response with &quot;application/pdf&quot; content type

Example of the seal image layout with **arbitrary text** which is added to the visual part of the seal(_KLASA: XXX-XX / XX-XX / XXXX, UBROJ: YYYYY-YYYYYY-YY-YY, Datum: DD.MM.YYYY._&quot; in the example figure) and a fixed position:

![Sealed document](https://assets.signator.eu/share/img/slika_8_api_doc.png)

#### Option 4: e-Seal with arbitrary image and position

#### Function: **SealDocumentWithPositionedImage**

> JSON Body input:

```json
{
  "File": "JVBERi0xLjUKJ … shortened … 3MAolJUVPRgo=",
  "SignatureImage": {
    "Page": 1,
    "WidgetOffsetX": 100,
    "WidgetOffsetY": 200,
    "WidgetWidth": 300,
    "WidgetHeight": 150,
    "ImageData": "JVBERi0xLjUKJ … shortened … 3MAolJUVPRgo="
  },
  "SignatureOptions": {
    "Reason": "New contract",
    "Location": "Zurich",
    "SignerContactInfo": "john.doe@example.com, Example ltd.",
    "SignerName": "John Doe"
  }
}
```

> If successful the above command returns code **200 OK** and Signed PDF document

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

Sealing a document with image and seal position.

`POST {{GATEWAYHOST}}/v/1/integrator/pdf/seal/image/positioned/`

- function name: **SealDocumentWithPositionedImage**
- implemented in: Signator
- caller: System X
- input parameters:
  - &quot;File&quot;\* - a document to be sealed
  - [&quot;SignatureImage&quot; \* - image that is added to the visual part of the seal](#positioning-of-the-signature-image-seal)
      - &quot;ImageData&quot;\* - base64 signature image
      - &quot;Page&quot; - page on which the seal is placed
      - &quot;WidgetOffsetX&quot; - seal position - lower left corner, x axis
      - &quot;WidgetOffsetY&quot; - seal position - lower left corner, y axis
      - &quot;WidgetWidth&quot; - height of the seal image
      - &quot;WidgetHeight&quot; - width of the seal image
  - &quot;SignatureOptions&quot;\*
      - &quot;Reason&quot; - razlog potpisa
      - &quot;Location&quot; - lokacija na kojoj je nastao potpis
      - &quot;SignerContactInfo&quot; - informacije o potpisniku
      - &quot;SignerName&quot; - ime potpisnika
  - &quot;ExternalSignerRegistryId&quot; - Optional parameter, this parameter enables switching between multiple different signing certificates when performing the eseal call
- output:
  - binary response with &quot;application/pdf&quot; content type

#### Function: **StoreDocument**

`{{GATEWAYHOST}}/v/1/integrator/store_document/`

> JSON Body input:

```json
{
  "SignedFile": "JVBERi0xLjUKJ … shortened for readability … 3MAolJUVPRgo="
}
```

> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
{
  "ProviderType": "EXAMPLE_DMS",
  "ProviderInfo": {
    "StorageProviderDocumentId": "AA/BB/CC-01"
  }
}
```

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

Function ensures that the document is saved to the central document management system if one exists (it can be DMS, eArchive, RMS, etc.).

- function name: **StoreDocument**
- implemented in: SystemX
- caller: Signator
- input parameters:
  - &quot;SignedFile&quot;\* - signed document
- output:
  - &quot;ProviderType&quot;\* - which system saves sealed documents
  - &quot;ProviderInfo&quot;\*
      - &quot;StorageProviderDocumentId&quot; - id of the document in central document management system

#### Document signing

External users have the ability to authenticate a document by scanning a QR code or entering a predefined URL and entering a record number and control number.

#### Function: **VerifyDocumentAuthenticity**

`POST {{GATEWAYHOST}}/v/1/integrator/verify_document_authenticity/`

> JSON Body input:

```json
{
  "StorageProviderDocumentId": "AA/BB/CC-01"
}
```

> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
{
  "AutenthicityDocument": "JVBERi0xLjUKJ … shortened for readability … 3MAolJUVPRgo="
}
```

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

The function provides a call from an external user who wants to verify a document by scanning a QR code drawn on the visual part of the seal or entering the URL of the verification page.

- function name: **VerifyDocumentAuthenticity**
- implemented in: SystemX
- caller: Signator
- input parameters:
  - &quot;StorageProviderDocumentId&quot;\* - ID of the document in central document management system
- output:
  - &quot;AuthenticityDocument&quot;\* - a document that is displayed to the end user who wants to verify the authenticity of the document. The company/institution determines how the information is displayed for the end user:
      - return of the sealed document
      - return of a document that has information about the authenticity of the document

It is up to SystemX to implement either the first or second option based on the client&#39;s decision. Signator always receives a document which it displays on the verification website.

Example of a QR code drawn on visual part of the seal is shown below. By scanning it, user will be redirected to the [verification page](#function-verifydocumentauthenticity)
with &quot;Record number&quot; and &quot;Control number&quot; fields being automatically filled. In case user is accessing verification page without scanning QR code (by entering page URL), &quot;Record number&quot; and &quot;Control number&quot; fields have to be filled manually.


![Verify document](https://assets.signator.eu/share/img/slika_9_api_doc.png)


#### Error feedback

All errors return the HTTP status code **400** , unless an unforeseen situation has occurred. In that case HTTP status code is **500.**

All errors are returned as **JSON**.

#### List of possible errors on Signator interface

- 2103 - Verification system not available
- 2104 - Attached document is not a PDF document
- 2105 - Missing &quot;RecordNumber&quot; parameter
- 2106 - Missing &quot;SystemId&quot; parameter
- 2107 - Missing &quot;File&quot; parameter
- 2108 - Missing &quot;ProviderData&quot; parameter
- 2109 - Missing &quot;ProviderType&quot; parameter
- 2110 - Required verification entry for update does not exist in database
- 2111 - Entry with &quot;RecordNumber&quot; already exists for &quot;SystemId&quot;
- 2112 - Unable to update for requested entry
- 2113 - Missing JWT token in request
- 2114 - JWT token has expired

In the event of any error, processing is interrupted at that point and the error response is returned to the caller.

A more detailed description of the error will be found in the info element.

## eForms

Signator has the ability to host pdf dynamic forms within its interface in a web browser. End user can select one from the list of published forms, fill it in and submit it. The submitted form is sent to the Signator backend in the form of a filled PDF document, which can also be digitally signed with a digital signature, with a list of all entered values ​​as JSON or XML structured data. It is also possible to send a completed and digitally signed PDF document to SystemX. The definition of the model can be found in the following diagram.

### **Representation of the integration model**
![Integration model](https://assets.signator.eu/share/img/slika_5_api_doc.png)

### Model description from the Signator perspective (Signator → SystemX)

#### Function: **StoreSubmittedForm**

> JSON Body input:

```json
{
  "documentId": 123,
  "documentUrl": "esign.example.com/#/v/1/document/3",
  "file": "JVBERi0xLjUKJ … shortened for readability … 3MAolJUVPRgo=",
  "fileType": "pdf",
  "fileName": "file name",
  "submittedFormIdentifier": "13",
  "submittedFormData": {
    "txtName": "Name",
    "txtSurname": "Surname",
    "txtMail": "examle@address.com"
  },
  "attachments": [
    {
      "file": "JVBERi0xLjUKJ … shortened for readability … 3MAolJUVPRgo=",
      "fileType": "xml",
      "fileName": "Attachment-12"
    }
  ]
}
```

> If successful the above command returns code **200 OK** and JSON body structured like this:

```json
{
  "documentId": 123
}
```

> Default error response

```json
{
  "type": "error",
  "info": "string",
  "errors": [
    {
      "property": "string",
      "errorCode": 0,
      "passedValue": "string"
    }
  ]
}
```

- After user filled the form Signator sends it in PDF format, together with filled fields in JSON format, to SystemX

`POST {{GATEWAYHOST}}/v/1/integrator/submitted_form/`

  - function name: **StoreSubmittedForm**
  - implemented in: SystemX
  - caller : Signator
  - input parameters:
    - &quot;documentId&quot;\* - documentId of the filled form from Signator,
    - &quot;documentUrl&quot;\* - path of the filled form,
    - &quot;file&quot;\* - pdf document in base64 format,
    - &quot;fileType&quot;\* - file type,
    - &quot;fileName&quot;\* - name of pdf document for digital signing,
    - &quot;submittedFormIdentifier&quot;\* - form identifier,
    - &quot;submittedFormData []&quot;\* - filled in data from the form in key: value format,
    - Attachments\* [file\*, fileType\*, fileName\*] - list of attachments with the form
      - &quot;File&quot; - attachment in base64 format,
      - &quot;fileType&quot; - document type,
      - &quot;fileName&quot; - attachment name,
  - output:
    - _response HTTP 200_


### Model description from the SystemX perspective (SystemX → Signator)

[Function: UpdateDocumentAttributes](#function-updatedocumentattributes)

## Positioning of the signature image/seal

The image below explains how the signature image/seal positioning option, used in the functions [StartApprovalProcess](#function-startapprovalprocess) and [SealDocumentWithPositionedText](#option-2-e-seal-with-arbitrary-text-and-position).

When sending parameters to determine the position of the signature image or seal, it is needed to convert your current viewport to a PDF viewport.

An example of a PDF document in figure below is shown in a coordinate system in dimensions of 612x792 units (A4 document). One unit in the PDF coordinate system is 1/72 of an inch.

The parameters to be sent are **&quot;WidgetOffsetX&quot;** (label in the image **&quot;LLX&quot;** ) and **&quot;WidgetOffsetY&quot;** (label in the image **&quot;LLY&quot;** ) as coordinates of the lower left corner of the widget, and **&quot;WidgetHeight&quot;** (label in the image **&quot;HEIGHT&quot;** ) and **&quot;WidgetWidth &quot;** (label in the image **&quot; WIDTH &quot;** ) as information about widget height and width in the coordinate system of the PDF document.

![Signature positioning image 1](https://assets.signator.eu/share/img/slika_10_api_doc.png)

The signature image is only one part of the widget (an example of the widget is in the image below), and that needs to be taken into account when determining the values ​​of the parameters to be sent.

![Signature positioning image 2](https://assets.signator.eu/share/img/slika_11_api_doc.png)
